<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" >
<head>
    <title>Database View-plug-ins Programming Helper</title>
</head>
<body>
<p><strong>Project Description</strong></p>
<p>The View-Plug-Ins Programming on database development is an interface-oriented programming. This methodology has been practiced widely in many fields (e.g. OOP programming) for a long time. Here just focus on database development and introduce a few meta-tables and helper packages (for Oracle, or set of stored procedures for SQL Server). The purpose is to simplify the design of many complex batches processing, useful for ETL, reporting and DWH solutions.</p>
<p>The central motive behind View-Plug-Ins is also a Branches-Leaves model of database development. Branches are stored procedures of flowchart while leaves are views of particular implementation. It helps to remind people <strong>pruning</strong> fruit trees during the growing season (in early stages of software lifecycle, from the system requirement analysis to design stage). Then in&nbsp;later maintenance stage, it would be more clear to organize/see the whole picture from the root to branches if the program structure of SQL scripts like a deciduous tree in winter.</p>
<p><strong>Interface Design</strong></p>
<p>The process of interface designing prefers more converse thinking. Especially in realization phase, the whole programming steps is from Target (output) Model to Source (input) Models, as shown following:<br /><img style="vertical-align: middle;" src="http://www.codeplex.com/Download?ProjectName=view&amp;DownloadId=463344" alt="Figure1" width="545" height="118" /></p>
<p>Once we get a clear and clean data requirement, then to abstract, induce and simplify into a unified target model is a prerequisite of interface-oriented designing.</p>
<ul>
<li>The Target Model (above figure) defines the data model; </li>
<li>A Interface defines a cluster node to approach one kind of required data; </li>
<li>A view-plug-in defines a method model of data extraction. </li>
</ul>
<p><img style="vertical-align: middle;" src="http://www.codeplex.com/Download?ProjectName=view&amp;DownloadId=463345" alt="Figure2" width="689" height="376" /></p>
<p>Two basic aims of bringing in the Interface and the Plug-ins:</p>
<p><span style="text-decoration: underline;">Isolation</span></p>
<p>To isolate the differences of data model, transform different model from many sources to a common target model, follow by classification, labeling/tagging etc. It helps the code to be loose-coupled while the data keep tightly-coupled. To test each independent view can be much clearer than to test a tangled of steps in sp, make the test-driven database development simple.</p>
<p><span style="text-decoration: underline;">Unification</span></p>
<p>A complex system can always be divided into a few clear-cut sub-systems with logical loose coupling integration. For database system design, the principle of division depends on the induction of data model. Then each target sub-system can be treated as one data model, the differences have been transformed into just some attributes in the same model.</p>
<p><strong>Meta Tables</strong></p>
<p>There are only 3 tables about meta data need to be maintained for above designed model:</p>
<ol>
<li>EXTRACT_INTERFACE </li>
<li>EXTRACT_PLUGIN </li>
<li>EXTRACT_RULE </li>
</ol>
<p>1. EXTRACT_INTERFACE</p>
<div>Sample:</div>
<table style="border: 1px solid #C0C0C0;" border="1" cellspacing="0" cellpadding="2">
<tbody>
<tr style="font-weight: bold;" align="center" bgcolor="gainsboro">
<td>INTERFACE_ID</td>
<td>UNION_VIEW</td>
<td>SELECT_LIST</td>
<td>DESCRIPTION_</td>
</tr>
<tr>
<td>PROD_CLASS</td>
<td>XYZ.VIEW_EXTRACT_PRODUCTS</td>
<td>BATCH_ID, SEC_ID, PROD_NAME</td>
<td>Holding Level Product Identification</td>
</tr>
<tr>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
</tr>
</tbody>
</table>
<div><span style="text-decoration: underline;">Columns</span><br />- INTERFACE_ID: The unique identifier for the interface, consider a naming convention within the enterprise.<br />- UNION_VIEW: The name of view which will union all plug-ins under the same interface.<br />- SELECT_LIST: The select list in the select statement, every plug-in view of the same interface will follow this signature.<br />- DESCRIPTION_:<br />&nbsp;</div>
<p>2. EXTRACT_PLUGIN</p>
<div>Sample:</div>
<table style="border: 1px solid #C0C0C0;" border="1" cellspacing="0" cellpadding="2">
<tbody>
<tr style="font-weight: bold;" align="center" bgcolor="gainsboro">
<td>PLUGIN_ID</td>
<td>INTERFACE_ID</td>
<td>PLUGIN_VIEW</td>
<td>PLUGIN_ORDER</td>
<td>DESCRIPTION_</td>
</tr>
<tr>
<td>PROD_CLASS_SERE</td>
<td>PROD_CLASS</td>
<td>XYZ.VIEW_PROD_CLASS_SERE</td>
<td>1</td>
<td>Identify products from SerE.</td>
</tr>
<tr>
<td>PROD_CLASS_SECM</td>
<td>PROD_CLASS</td>
<td>XYZ.VIEW_PROD_CLASS_SECM</td>
<td>2</td>
<td>Identify products from SecM.</td>
</tr>
<tr>
<td>PROD_CLASS_DEAL</td>
<td>PROD_CLASS</td>
<td>XYZ.VIEW_PROD_CLASS_DEAL</td>
<td>3</td>
<td>Identify products from DeaL.</td>
</tr>
<tr>
<td>PROD_CLASS_BSK</td>
<td>PROD_CLASS</td>
<td>XYZ.VIEW_PROD_CLASS_BSK</td>
<td>4</td>
<td>Identify products from Bsk.</td>
</tr>
<tr>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
</tr>
</tbody>
</table>
<div><span style="text-decoration: underline;">Columns</span><br />- PLUGIN_ID: The unique identifier for the plug-in, consider a naming convention within the enterprise.<br />- INTERFACE_ID: The interface of the plug-in belongs to.<br />- PLUGIN_VIEW: The view which will implement the plug-in.<br />- PLUGIN_ORDER: The order where the plug-in will be assembled in the interface union view.<br />- DESCRIPTION_:<br />&nbsp;</div>
<p>3. EXTRACT_RULE</p>
<div>Sample:</div>
<table style="border: 1px solid #C0C0C0;" border="1" cellspacing="0" cellpadding="2">
<tbody>
<tr style="font-weight: bold;" align="center" bgcolor="gainsboro">
<td>RULE_ID</td>
<td>PLUGIN_ID</td>
<td>TAG$01</td>
<td>TAG$02</td>
<td>TAG$03</td>
<td>TAG$04</td>
<td>...</td>
</tr>
<tr>
<td>1</td>
<td>PROD_CLASS_BSK</td>
<td>EQUITY BASKET SWAP</td>
<td>SEC</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
</tr>
<tr>
<td>2</td>
<td>PROD_CLASS_SECM</td>
<td>CONVERTIBLE BOND</td>
<td>SEC</td>
<td>DEBT</td>
<td>CONVERTIBLE</td>
<td>&nbsp;</td>
</tr>
<tr>
<td>3</td>
<td>PROD_CLASS_SECM</td>
<td>LISTED EQUITY INDEX OPTION</td>
<td>SEC</td>
<td>LISTED_OPTION</td>
<td>INDEX</td>
<td>&nbsp;</td>
</tr>
<tr>
<td>4</td>
<td>PROD_CLASS_SECM</td>
<td>LISTED EQUITY OPTION</td>
<td>SEC</td>
<td>LISTED_OPTION</td>
<td>EQUITY</td>
<td>&nbsp;</td>
</tr>
<tr>
<td>5</td>
<td>PROD_CLASS_SECM</td>
<td>OTC EQUITY INDEX OPTION</td>
<td>SEC</td>
<td>OTC_OPTION</td>
<td>INDEX</td>
<td>&nbsp;</td>
</tr>
<tr>
<td>6</td>
<td>PROD_CLASS_SECM</td>
<td>OTC EQUITY OPTION</td>
<td>SEC</td>
<td>OTC_OPTION</td>
<td>EQUITY</td>
<td>&nbsp;</td>
</tr>
<tr>
<td>7</td>
<td>PROD_CLASS_SECM</td>
<td>RIGHT</td>
<td>SEC</td>
<td>EQUITY</td>
<td>RIGHT</td>
<td>&nbsp;</td>
</tr>
<tr>
<td>8</td>
<td>PROD_CLASS_SECM</td>
<td>SINGLE NAME FUTURE</td>
<td>SEC</td>
<td>FUTURE</td>
<td>DEBT</td>
<td>&nbsp;</td>
</tr>
<tr>
<td>9</td>
<td>PROD_CLASS_SECM</td>
<td>SYNTHETIC EQUITY SWAP</td>
<td>SEC</td>
<td>SES_LEG</td>
<td>EQUITY_LEG</td>
<td>&nbsp;</td>
</tr>
<tr>
<td>10</td>
<td>PROD_CLASS_SECM</td>
<td>TOTAL RETURN SWAP</td>
<td>SEC</td>
<td>SWAP</td>
<td>TOTAL_RETURN</td>
<td>&nbsp;</td>
</tr>
<tr>
<td>11</td>
<td>PROD_CLASS_SECM</td>
<td>WARRANT</td>
<td>SEC</td>
<td>EQUITY</td>
<td>WARRANT</td>
<td>&nbsp;</td>
</tr>
<tr>
<td>12</td>
<td>PROD_CLASS_DEAL</td>
<td>EQUITY INDEX SWAP</td>
<td>SEC</td>
<td>SWAP</td>
<td>INDEX</td>
<td>&nbsp;</td>
</tr>
<tr>
<td>13</td>
<td>PROD_CLASS_DEAL</td>
<td>INDEX FORWARD</td>
<td>SEC</td>
<td>FORWARD</td>
<td>INDEX</td>
<td>&nbsp;</td>
</tr>
<tr>
<td>14</td>
<td>PROD_CLASS_DEAL</td>
<td>INDEX FUTURE</td>
<td>SEC</td>
<td>FUTURE</td>
<td>INDEX</td>
<td>&nbsp;</td>
</tr>
<tr>
<td>15</td>
<td>PROD_CLASS_SERE</td>
<td>ADR</td>
<td>SEC</td>
<td>E</td>
<td>ADR</td>
<td>&nbsp;</td>
</tr>
<tr>
<td>16</td>
<td>PROD_CLASS_SERE</td>
<td>COMMON EQUITY</td>
<td>SEC</td>
<td>E</td>
<td>COM</td>
<td>&nbsp;</td>
</tr>
<tr>
<td>17</td>
<td>PROD_CLASS_SERE</td>
<td>PREFERRED SHARE</td>
<td>SEC</td>
<td>E</td>
<td>CON</td>
<td>&nbsp;</td>
</tr>
<tr>
<td>18</td>
<td>PROD_CLASS_SERE</td>
<td>EXCHANGE TRADED FUND</td>
<td>SEC</td>
<td>E</td>
<td>ETF</td>
<td>&nbsp;</td>
</tr>
<tr>
<td>19</td>
<td>PROD_CLASS_SERE</td>
<td>GDR</td>
<td>SEC</td>
<td>E</td>
<td>GDR</td>
<td>&nbsp;</td>
</tr>
<tr>
<td>20</td>
<td>PROD_CLASS_SERE</td>
<td>PREFERRED SHARE</td>
<td>SEC</td>
<td>E</td>
<td>PRF</td>
<td>&nbsp;</td>
</tr>
<tr>
<td>21</td>
<td>PROD_CLASS_SERE</td>
<td>UNIT</td>
<td>SEC</td>
<td>E</td>
<td>UNT</td>
<td>&nbsp;</td>
</tr>
<tr>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
</tr>
</tbody>
</table>
<div><span style="text-decoration: underline;">Columns</span><br />- RULE_ID: The primary key of this table is pointless, it just means one unique rule. The business key should be in one or some of TAG$... columns. The integrity of rules configuration must be checked manually.<br />- PLUGIN_ID: This rule will be applied to which plug-in.<br />- TAG$01: A constant parameter to be used by the extraction plug-in view.<br />- TAG$02: ..<br />- TAG$03: ..<br />- TAG$04: ..<br />- TAG$05: ..<br />- TAG$06: ..<br />- TAG$07: ..<br />- TAG$08: ..<br />- TAG$09: ..<br />- TAG$10: ..<br />- TAG$11: ..<br />- TAG$12: ..<br />- TAG$13: ..<br />- TAG$14: ..<br />- TAG$15: ..<br />- TAG$16: ..<br />&nbsp;</div>
<p>These TAG$.. columns look a bit ugly for maintenance. From the viewpoint of practical business, all rules under a interface are in the same category. So create a rule-view for each interface specially can solve the ugliness.<br />
A trigger will create a new declaration of columns alias in EXTRACT_RULE_TAG_ALIAS table while a new interface is being added into EXTRACT_INTERFACE table, assign intelligible alias to corresponding appliable columns. </p>
<p>Above example is extracting and classifying hundreds of different product type from various source systems.</p>
<ul>
<li>The table EXTRACT_RULE induces them into a few extraction models, and centralizes all constant parameters (tags) to minimize hard-code queries. </li>
<li>Each extraction model expresss as a plug-in view. The table EXTRACT_PLUGIN describes which view presents the realization of each plug-in and which interface need to follow. </li>
<li>The table EXTRACT_INTERFACE declares the view signature of each interface (like delegate in C#), and the union view which assembles all its plug-in views. The code of union views can be generated by following helper view: </li>
</ul>
<p style="padding-left: 30px;">SELECT * FROM VPI.VIEW_EXTRACT_GEN_CODE<br /><img src="http://download-codeplex.sec.s-msft.com/Download?ProjectName=view&amp;DownloadId=464809" alt="view_extract_gen_code" width="354" height="42" /><br />Click the &lt;CLOB&gt;..., the generated code will be show in a pop-up window of PL/SQL.</p>
<p><strong>Session Context</strong></p>
<p>In order to pass some parameters to a batch processing of views (like a OOP class with a parameterless constructor only), the session context is introduced in each batch of extraction processing. The package VPI.EXTRACT_UTILITY provides some functions/procedures to operate the session context.</p>
<ol>
<li>CREATE_BATCH: The constructor of batch session, this function return a new BATCH_ID. </li>
<li>SET_PARAMS: Set properties in a batch session for passing variables cross views. These variables are stored in table EXTRACT_BATCH. </li>
</ol>
<p>For most batch processings, people would like to trace the progress updates during the processing, such as elapsed time, current status, % in progress bar, etc.</p>
<ol>
<li>PROGRESS_START: This procedure initializes how many steps will the batch process. </li>
<li>PROGRESS_UPDATE: This procedure updates current status. </li>
</ol>
<div>For example (Oracle version):</div>
<div style="color: black; background-color: white;">
<pre><span style="color: blue;">PROCEDURE</span> ETL_MAIN
(
    inDate  <span style="color: blue;">DATE</span>
) <span style="color: blue;">IS</span>
tBatch_ID   PLS_INTEGER := <span style="color: #c0c0c0;">VPI.</span><span style="color: #808080;">EXTRACT_UTILITY.</span>CREATE_BATCH(<span style="color: #a31515;">'CO.GRP.PRD.ETL'</span>);
<span style="color: blue;">BEGIN</span>
    <span style="color: #c0c0c0;">VPI.</span><span style="color: #808080;">EXTRACT_UTILITY.</span>SET_PARAMS(tBatch_ID, <span style="color: #a31515;">'2012-07-31'</span>);

    <span style="color: #c0c0c0;">VPI.</span><span style="color: #808080;">EXTRACT_UTILITY.</span>PROGRESS_START(12, 1, <span style="color: #a31515;">'Preloading(cleaning) some crucial slow sources ...'</span>);
    PRELOAD_CACHE_SECM(tBatch_ID);

    <span style="color: #c0c0c0;">VPI.</span><span style="color: #808080;">EXTRACT_UTILITY.</span>PROGRESS_UPDATE(<span style="color: #808080;">inProgress_Description =&gt;</span>
        <span style="color: #a31515;">'Loading positions ...'</span>);
    LOAD_POSITIONS(tBatch_ID);

    <span style="color: #c0c0c0;">VPI.</span><span style="color: #808080;">EXTRACT_UTILITY.</span>PROGRESS_UPDATE(<span style="color: #808080;">inProgress_Description =&gt;</span>
        <span style="color: #a31515;">'Loading top level securities and classifying product types ...'</span>);
    LOAD_TOP_LEVEL_SECURITIES(tBatch_ID);

    <span style="color: #c0c0c0;">VPI.</span><span style="color: #808080;">EXTRACT_UTILITY.</span>PROGRESS_UPDATE(<span style="color: #808080;">inProgress_Description =&gt;</span>
        <span style="color: #a31515;">'Loading middle level securities ...'</span>);
    LOAD_MID_LEVEL_SECURITIES(tBatch_ID);

    <span style="color: #c0c0c0;">VPI.</span><span style="color: #808080;">EXTRACT_UTILITY.</span>PROGRESS_UPDATE(<span style="color: #808080;">inProgress_Description =&gt;</span>
        <span style="color: #a31515;">'Loading bottom level securities ...'</span>);
    LOAD_BTM_LEVEL_SECURITIES(tBatch_ID);

    <span style="color: #c0c0c0;">VPI.</span><span style="color: #808080;">EXTRACT_UTILITY.</span>PROGRESS_UPDATE(<span style="color: #808080;">inProgress_Description =&gt;</span> <span style="color: #a31515;">'Loading issuers ...'</span>);
    LOAD_ISSUERS(tBatch_ID);

    ...

    <span style="color: #c0c0c0;">VPI.</span><span style="color: #808080;">EXTRACT_UTILITY.</span>PROGRESS_UPDATE(<span style="color: #808080;">inProgress_Description =&gt;</span> <span style="color: #a31515;">'Done.'</span>);
<span style="color: blue;">END</span> MAIN;</pre>
</div>
<p>Then the view VIEW_EXTRACT_BATCH_LOG or VIEW_LAST_BATCH_LOG can be used to mornitor the whole batch progress in background.<br />Or, UI can use the procedure EXTRACT_UTILITY.POLLING_PROGRESS to display a progress bar.</p>
<p><strong>Query Optimization</strong></p>
<p>Avoid/minimize using dynamic SQL and temp tables for extraction, SQL expression errors should be discovered at compile-time. Database view provides a facility for this, the execution plan is prepared when compiling the query, every query can be clearly optimized in advance.</p>
<p><strong>Data Quality</strong></p>
<p>The quality of source data always affects queries' performance disastrously.<br />Bad data: missing, duplicate, impossible values ...<br />For instance,<br />- Data missing requires you have to use OUTER JOIN instead of INNER JOIN; <br />- Data duplication requires you to have a extra MIN/MAX...GROUP BY...;<br />...<br />You are not allowed to use straightforward SQL in these situations, but to complicate and slow down queries everywhere painfully! Some romantic business requirements even would ask you to split a regular JOIN SQL into several broken steps and check potential data error at every step, mark error flags, try this side, try that side and continue... Imagine there are some land mines were laid along the highway, then every vehicles are required to be mine-clearing vehicles!<br />It is utterly opposed to the principle of using Structured Query Language.<br />Everyone known in theory, "there is no bad data, but only bad applications(producers)". But in some companies for some reasons, once a new case of data exception was exposed, the requirements always ask downstream applications/reports to handle new error logic, instead of putting constraints in database and fixing upstream applications of data producer to prevent such case happend again. - Isn't it the Emperor's New Clothes, every eyewitness have to draw a new clothes on their own glasses!<br />As a downstream application/report, normally it's also difficult to ask those tables in source systems to add proper indexes for optimizing high frequency queries or bottleneck queries of data consumers.<br />... All thus limitation of fact prompted us to own a isolated clean data environment, we should no longer to drive mine-clearing vehicles on the highway. So a preprocess of source data clean-up becames very helpful for the performance of all follow-up batch extractions. Base on the thinking of view-plug-ins, a Relationship Clean-up Engine will be introduced shortly, since in most&nbsp;cases of&nbsp;bad data, the bad relationship is the most headache of headaches.</p>
<p><strong>Supported Databases</strong></p>
<ul>
<li>Oracle<br />- Currently support. </li>
<li>SQL Server<br />- In the plan ... </li>
</ul>
</body>
</html>
